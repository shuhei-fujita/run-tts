import os
import io
import sys
import subprocess
import threading
from pathlib import Path
from pydub import AudioSegment
from tqdm import tqdm
from openai import OpenAI
from dotenv import load_dotenv
import argparse
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, CHAP, USLT, COMM, CHAP
import math
import re
from ebooklib import epub
from bs4 import BeautifulSoup

MAX_LENGTH = 4096  # テキストの最大長
MAX_RETRIES = 3  # 最大再試行回数


# 開始時間を計算するためのヘルパー関数
def calculate_start_time(chapter_start, text, audio_length):
    text_length = len(text)
    return int((chapter_start / text_length) * audio_length)


# チャプター情報を抽出する関数
def extract_chapters(text, audio_file_path):
    # 音声ファイルの長さ（ミリ秒）
    audio = MP3(audio_file_path)
    audio_length = len(audio)

    chapters = []
    pattern = re.compile(r"\d+\.\s+.+")

    # 変換されたテキストを行ごとに処理
    lines = text.splitlines()
    for i, line in enumerate(lines):
        if pattern.match(line):
            # 元のテキスト内でのチャプタータイトルの位置を見つける
            chapter_start = text.find(line)
            if chapter_start != -1:
                # 音声ファイル内でのおおよその開始時間を計算
                # 例: テキストの長さと音声ファイルの長さに基づいて時間を割り出す
                start_time = calculate_start_time(chapter_start, text, audio_length)
                chapters.append(
                    {
                        "title": line.strip(),
                        "start_line": len(chapters),
                        "start_time": start_time,
                        "end_time": None,
                    }
                )

    # 終了時間を設定
    for i in range(len(chapters) - 1):
        chapters[i]["end_time"] = chapters[i + 1]["start_time"]

    # 最後のチャプターの終了時間を音声ファイルの長さに設定
    if chapters:
        chapters[-1]["end_time"] = audio_length

    return chapters


# メタデータを音声ファイルに追加する関数
def add_metadata_to_audio(file_path, text, chapters):
    audio_file_path = Path("mp3") / f"{Path(file_path).stem}.mp3"
    if not audio_file_path.exists():
        print(f"Error: Audio file {audio_file_path} does not exist.")
        return

    audio = MP3(str(audio_file_path), ID3=ID3)

    # メタデータを設定
    audio.tags.add(TIT2(encoding=3, text=Path(file_path).stem))
    audio.tags.add(USLT(encoding=3, lang="eng", desc="original", text=text))
    audio.tags.add(
        COMM(encoding=3, lang="eng", desc="Comment", text="Generated by OpenAI API")
    )

    # チャプター情報の追加
    for chapter in chapters:
        start_time = chapter["start_time"]  # チャプターの開始時間（ミリ秒）
        end_time = chapter["end_time"]  # チャプターの終了時間（ミリ秒）
        chapter_id = f"chp{chapter['start_line'] + 1}".encode("utf-8")
        audio.tags.add(
            CHAP(
                element_id=chapter_id,
                start_time=start_time,
                end_time=end_time,
                sub_frames=[TIT2(encoding=3, text=chapter["title"])],
            )
        )

    # .lrcファイルから歌詞情報を読み込んで追加
    lrc_file_path = Path("text") / "lyrics.lrc"
    with open(lrc_file_path, "r", encoding="utf-8") as lrc_file:
        lrc_text = lrc_file.read()
        audio.tags.add(USLT(encoding=3, lang="eng", desc="lrc", text=lrc_text))

    audio.save()


def sync_s3():
    print("Starting S3 sync...")
    command = [
        "aws",
        "s3",
        "sync",
        "mp3",
        "s3://play-audio-ios",
        "--profile",
        "private-fujita",
    ]
    result = subprocess.run(command, capture_output=True, text=True)
    if result.returncode == 0:
        print("S3 sync completed successfully.")
    else:
        print(f"S3 sync failed with error: {result.stderr}")


def extract_text_from_epub(epub_file_path):
    # .epubファイルを開く
    book = epub.read_epub(epub_file_path)

    # テキストを格納する変数を初期化
    text = ""

    # .epubファイル内の各ページを処理
    for item in book.items:
        if item.get_type() == 9:  # 9はHTMLドキュメントを示します
            # BeautifulSoupを使用してHTMLをパース
            soup = BeautifulSoup(item.content, "html.parser")
            # ページ内のテキストを抽出
            page_text = soup.get_text()
            # ページのテキストを全体のテキストに追加
            text += page_text + "\n"

    return text


def read_file(file_path):
    with open(file_path, "rb") as file:
        # バイナリモードでファイルを読み取り、UTF-8エンコーディングでデコード
        text = file.read().decode("utf-8")

    return text


def split_into_chunks(text, max_length):
    words = text.split()
    chunks = []
    current_chunk = ""
    for word in words:
        if len(current_chunk) + len(word) + 1 > max_length:
            chunks.append(current_chunk)
            current_chunk = word
        else:
            current_chunk += " " + word
    chunks.append(current_chunk)
    return chunks


def create_audio_segment(response):
    return AudioSegment.from_file(io.BytesIO(response.content), format="mp3")


def generate_speech(client, text, model_name, voice):
    retry_count = 0
    while retry_count < MAX_RETRIES:
        try:
            return client.audio.speech.create(
                model=model_name, voice=voice, input=text.strip()
            )
        except Exception as e:
            print(
                f"Error in API call: {e}. Retrying ({retry_count+1}/{MAX_RETRIES})..."
            )
            retry_count += 1
    return None


def process_text_block(
    client, text, model_name, voice, block_number, results, progress_bar, lock
):
    print(f"Processing block {block_number}...")
    try:
        response = generate_speech(client, text, model_name, voice)
        if response:
            with lock:
                results[block_number] = create_audio_segment(response)
    except Exception as e:
        print(f"Error processing block {block_number}: {e}")
    finally:
        with lock:
            progress_bar.update(1)


def combine_audio_segments(results):
    combined_audio = AudioSegment.empty()
    for segment in results:
        if segment:
            combined_audio += segment
    return combined_audio


def convert_mp3_to_aac(mp3_file_path):
    mp3_file_path = Path(mp3_file_path)  # Pathオブジェクトに変換
    aac_file_path = mp3_file_path.with_suffix(".aac")
    command = [
        "ffmpeg",
        "-i",
        str(mp3_file_path),
        "-c:a",
        "aac",
        str(aac_file_path),
    ]
    result = subprocess.run(command, capture_output=True, text=True)
    if result.returncode == 0:
        print(f"Converted to AAC: {aac_file_path}")
    else:
        print(f"Error converting to AAC: {result.stderr}")


def main(text_file_path, model, audio_format):
    load_dotenv()
    openai_api_key = os.getenv("OPENAI_API_KEY")
    client = OpenAI(api_key=openai_api_key)

    if text_file_path.endswith(".epub"):
        # .epubファイルの場合
        text = extract_text_from_epub(text_file_path)
    elif text_file_path.endswith(".txt"):
        # .txtファイルの場合
        text = read_file(text_file_path)
    else:
        print("Unsupported file format. Please provide a .txt or .epub file.")
        return

    # text = read_file(text_file_path)
    chunks = split_into_chunks(text, MAX_LENGTH)

    progress_bar = tqdm(total=len(chunks), desc="Processing")
    lock = threading.Lock()
    results = [None] * len(chunks)
    threads = []

    for i, chunk in enumerate(chunks):
        thread = threading.Thread(
            target=process_text_block,
            args=(client, chunk, model, "nova", i, results, progress_bar, lock),
        )
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()
    progress_bar.close()

    combined_audio = combine_audio_segments(results)
    mp3_output_file = Path("mp3") / f"{Path(text_file_path).stem}.mp3"
    combined_audio.export(mp3_output_file)
    print(
        f"Combined speech saved as {Path('mp3') / f'{Path(text_file_path).stem}.mp3'}"
    )

    # チャプター情報を抽出
    chapters = extract_chapters(text, mp3_output_file)

    # メタデータの追加
    if audio_format == "mp3":
        add_metadata_to_audio(text_file_path, text, chapters)

    # AACに変換が必要な場合
    if audio_format == "aac":
        convert_mp3_to_aac(mp3_output_file)

    # sync_s3()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Text-to-Speech script using OpenAI's API.",
        epilog="Usage example: python tts-openai.py example.txt --model tts-1-hd --format mp3",
    )
    parser.add_argument("text_file_path", help="Path to the text file.")
    parser.add_argument(
        "--model",
        default="tts-1",
        choices=["tts-1", "tts-1-hd"],
        help="Model to use for text-to-speech. Choices are tts-1 or tts-1-hd. Default is tts-1.",
    )
    parser.add_argument(
        "--format",
        default="mp3",
        choices=["mp3", "aac"],
        help="Audio format for the output file. Choices are mp3 or aac. Default is mp3.",
    )
    args = parser.parse_args()

    main(args.text_file_path, args.model, args.format)
